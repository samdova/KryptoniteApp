# KryptoniteApp
KryptoniteApp Two-Factor Authentication (2FA) system  Backend API

## Table of Contents
- [Description](#description)
- [Installation](#installation)
- [Usage Guide](#usage_guide)
- [Configuration](#configuration)
- [Authentication and Authorization](#authentication_authorization)
- [Error Handling](#error_handling)
- [QaTesting](#qatesting)
- [Contribution Guidelines](#contribution_guidelines)


## Description
KryptoniteApp Two-Factor Authentication (2FA) system  Backend API follows a RESTful architecture, with endpoints organized logically to facilitate efficient and seamless registration (where a unique and default apikey is generated and stored to the database), upon registration, receives a confirmation email to verify email, email including link attached with otp generated by redis, which is used to authenticate and confirm the user mail and proceeds to log in. The login process involves 2FA, where a user enters their email address, a six-digit One-Time Password (OTP handled by redis) is generated and sent to the provided email address. On authenticating the otp and email, a token (generated by redis) is created with an expiry time used for subsequent requests. The system also create api endpoint to create different apikey and also endpoint to invalidate the apikey. Endpoint to also upload file (image) using the user unique apikey. Endpoint for getting image by Id and also for getting all images in the database, this two api endpoint doesn't requires authorization and authentication.

## Installation
To get started with the backend API project, follow these steps:

1. Clone the repository to your local machine using the following command:

   git clone https://github.com/samdova/KryptoniteApp.git

2. Navigate to the project directory:

   cd <KryptoniteApp>

3. Install the required dependencies by running the following command:

   yarn install

4. Set up the configuration file:

   - Open the `.env` file and update the necessary configuration variables such as database credentials or API keys.

5. Start the API server:

   yarn start

6. The API will now be running locally on `http://localhost:3000`. You can test the endpoints using a tool like Postman or by making HTTP requests directly.

That's it! You have successfully installed and set up the backend API project. You can now begin using the API and integrating it into your applications.


## Usage Guide
Endpoints, request formats, and response . Errors are caught and appropriate error messages are returned in the response.

POST /api/auth/register
  ° Register a new user.
  ° Request Body: { "email": "email@gmail.com" } 
  ° Response: { user: newUser._id, message: 'Registered successfully. Please check your email to confirm your registration. The link expires in One hour', otp: token  } 

GET /api/auth/confirm-email?email=email@gmail.com&token=123456
  ° Confirm new user email.
  ° req.query: { "email": "email@gmail.com", "token": "123456" } 
  ° Response: { user: user._id, user_key: user.apikey, message: 'Email confirmed successfully', next: '/login' } 

POST /api/auth/login
  ° Login an existing user.
  ° Request Body: { "email": "example@example.com" } 
  ° Response: { message: 'OTP sent to email', otp: otp, next: '/verify-otp' } 

POST /api/auth/verify-otp
  ° Verify Login otp and login
  ° Request Body: { "email": "email@gmail.com", "otp": "123456" } 
  ° Response: { token } 

POST /api-key/create
  ° Create a new unique apikey
  ° Request Header: { "Authorization": "token" } 
  ° Request Body: { "email": "email@gmail.com", "apiKey": "apiKey" } 
  ° Response: { apiKey: newApiKey } 

POST /api-key/invalidate
  ° Invalidate an existing unique apikey
  ° Request Header: { "Authorization": "token" } 
  ° Request Body: { "email": "email@gmail.com", "apiKey": "apiKey" } 
  ° Response: { message: 'API key invalidated successfully' } 

POST /api/auth/logout
  ° Invalidate an existing unique apikey
  ° Request Header: { "Authorization": "token" } 
  ° Response: { message: 'Logged out successfully'  } 

POST /api/files/upload
  ° Upload File (image)
  ° Request Header: { "Authorization": "token", "apikey": "apikey" } 
  ° Request Body - form-data: { "file": "file.jpg" } \\ Choose the image file you want to upload. 
  ° Response: { message: 'Logged out successfully'  } 


GET /api/images
  ° Get all images
  ° Response: const images = files.reduce((acc, file) => {
            const userImages = file.images.map(image => ({
                data: image.data,
                email: file.email,
                apiKey: image.apiKey,
                dateUploaded: image.dateUploaded,
            }));
            return acc.concat(userImages);   
        }, []);

        res.status(200).json(images);

GET /api/images/:id
  ° Get all images
  ° Request Body - req.params: { "id": "image_id_goes here" } 
  ° Response: const response = {
            data: image.data,
            email: file.email,
            apiKey: image.apiKey,
            dateUploaded: image.dateUploaded,
        };

        res.status(200).json(response);


## Configuration
The project makes use of mongodb for storing data. A .env file already exist, but incase of creating yours, below are guideline 

1. Install MongoDB: If you haven't already, you'll need to install MongoDB on your machine. You can download it from the official MongoDB website and follow the installation instructions for your operating system.

2. Start MongoDB: Once MongoDB is installed, start the MongoDB server on your machine. The exact command may vary depending on your operating system. For example, on macOS, you can open a terminal window and run the command `mongod` to start the server.

3. Connect to MongoDB: Open another terminal window and run the command `mongo` to start the MongoDB shell. This will allow you to interact with the MongoDB server.

4. Create a Database: In the MongoDB shell, you can create a new database by running the following command:

   use your-database-name
   Replace `your-database-name` with the desired name for your database.

5. Create a Collection: A collection is a group of documents within a database. You can create a collection by running the following command in the MongoDB shell:

   db.createCollection("your-collection-name")
   Replace `your-collection-name` with the desired name for your collection.

6. Generate Connection String: To store the connection details in the `.env` file, you'll need to generate a connection string. The connection string should include the MongoDB server address, the database name, and any required authentication credentials. Here's an example of a connection string:

   MONGODB_URI=mongodb://username:password@localhost:27017/your-database-name
   Replace `username`, `password`, and `your-database-name` with your actual values.

7. Store Connection Details in .env: Create a new file named `.env` in the root directory of your project. Open the file and add the connection string from the previous step:

   MONGODB_URI=mongodb://username:password@localhost:27017/your-database-name

8. Access Connection Details: In your project code, you can access the connection details stored in the `.env` file using a library like `dotenv`. This allows you to retrieve the connection string and establish a connection to the MongoDB database.

That's it! You have now created a database in MongoDB and stored the connection details in the `.env` file.



## Authentication and Authorization
1. Authentication:
In KryptoniteApp, authentication involves registering users, confirming their email addresses, logging in with email and OTP (One-Time Password), and issuing time based token (token controlled by redis) for subsequent requests.

User Registration:
When a user registers, they provide an email. The system generates an API key and creates a new user record in the database. A confirmation email with a token is sent to the user's email address. The token is stored in Redis with a 1-hour expiration.

Email Confirmation:
The user clicks the link in the confirmation email. The system verifies the token and confirms the user's email if the token is valid. The token is deleted from Redis once the email is confirmed.

Login with 2FA:
The user provides their email to log in. The system checks if the email is registered and confirmed.
If valid, a 6-digit OTP is generated and sent to the user's email. The OTP is stored in Redis with a 5-minute expiration.

Verify OTP and token Issuance:
The user provides the OTP. The system checks the OTP against the value stored in Redis. If valid, a token is generated and stored in Redis with a 1-hour expiration.The token is returned to the user for subsequent requests.

2. Authorization:
In KryptoniteApp, authorization is managed using the token issued during authentication and apikey.

Token:
A token contains the user's email and is signed with a secret key. The token is included in the Authorization header of subsequent requests.

Protect Middleware:
Middleware protect is used to guard routes that require authentication. The middleware extracts the token from the Authorization header. The token is verified. If valid, the email associated with the token is retrieved from Redis.
If the token is invalid or expired, the request is rejected with a 401 Unauthorized status. If valid, the request proceeds, and the user's email is attached to the request object.

Protected Routes:
Routes like creating or invalidating API keys are protected using the protect middleware. Only authenticated users with a valid token can access these routes.


## Error Handling
We ensure a seamless experience for users navigating the KryptoniteApp, where every interaction, even when things go awry, is met with clarity and guidance. Error responses will be designed for consistency across all endpoints, leveraging the power of JSON for clear communication.

// Handle authRoute  errors
const handleErrors = (err) => {
  console.log(err.message, err.code);
  let errors = { email: '', otp: '', apiKey: '', token: '' };

  // Incorrect email
  if (err.message === 'email not registered') {
    errors.email = 'Email does not exist';
  }
  if (err.message === 'Email is required') {
    errors.email = 'Input Email, email is required';
  }
  if (err.message === 'Invalid or expired token') {
    errors.otp = 'Invalid or expired link';
  }
  if (err.message === 'API key already exists') {
    errors.apiKey = 'API key already exists';
  }
  if (err.message === 'API key is required') {
    errors.apiKey = 'API key is required';
  }
  if (err.message === 'Token is required') {
    errors.token = 'Input Token, token is required';
  }
  if (err.message === 'otp is required') {
    errors.otp = 'otp is required';
  }
  
  // Duplicate error code
  if (err.code === 11000) {
    errors.email = 'Email already registered';
    return errors;
  }
  // Validation errors
  if (err.message.includes('user validation failed')) {
    Object.values(err.errors).forEach(({ properties }) => {
      errors[properties.path] = properties.message;
    });
  }
  return errors;
};

// Handle fileRoute  errors
const handleErrors = (err) => {
    console.error(err.message, err.code); 
    let errors = { email: '', apiKey: '' };

    if (err.message === 'Email not registered') {
        errors.email = 'Email does not exist';
    }

    if (err.message === 'Email not confirmed') {
        errors.email = 'Email not confirmed. Please confirm your email first.';
    }

    if (err.code === 11000) {
        errors.email = 'Email already registered';
        return errors;
    }

    if (err.message.includes('user validation failed')) {
        Object.values(err.errors).forEach(({ properties }) => {
            errors[properties.path] = properties.message;
        });
    }

    if (err.message === 'User not found') {
        errors.email = 'User not found';
    }

    if (err.message.startsWith('Invalid or invalidated API key')) {
        errors.apiKey = err.message;
    }

    return errors;
};


## QATesting
After cloning the project, run 

yarn install

yarn start

Then, open the browser and run it locally using 

localhost:3000/

depending on your port number (assuming 3000 is declared the port number)

Also make sure the .env file and database is created successfully, open Insommia (or any other application preffered for testing our api endpoint)


## Contribution Guidelines
Thank you for your interest in contributing to our project! We welcome contributions from the community to help make our project even better. Here are some guidelines on how you can contribute:

1. Reporting Bugs:
   - If you come across any bugs or issues while using our project, please submit a detailed bug report.
   - Include steps to reproduce the bug, expected behavior, and actual behavior.
   - If possible, provide screenshots or code snippets that can help us understand the issue better.
   - You can submit bug reports through our issue tracker on GitHub.

2. Requesting Features:
   - If you have a feature request or an idea to enhance our project, we would love to hear it!
   - Describe the feature or enhancement you would like to see, and explain why it would be valuable.
   - Provide any relevant details or specifications that can help us understand your request.
   - You can submit feature requests through our issue tracker on GitHub.

3. Making Code Contributions:
   - If you are interested in contributing code to our project, we encourage you to do so!
   - Fork the project repository on GitHub and create a new branch for your contribution.
   - Make your changes, ensuring they follow our coding conventions and best practices.
   - Submit a pull request with a clear description of your changes and the problem they solve.
   - Our team will review your pull request and provide feedback or merge it if it meets our criteria.

Please note that all contributions are subject to review and approval by our team. We appreciate your understanding and patience throughout the process.

By contributing to our project, you agree to abide by our code of conduct and licensing terms.

Thank you for considering contributing to our project! We value the efforts and ideas of our community members. Together, we can make our project even more successful.